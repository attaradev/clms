name: clms

services:
  # --- PHP-FPM (Laravel runtime + Composer on start) ---
  php:
    container_name: clms-php
    build:
      context: ./back-end
      dockerfile: dockerfiles/php.dockerfile
      args:
        UID: ${UID:-1000}
        GID: ${GID:-1000}
        USER: ${USER:-app}
    env_file:
      - ./back-end/.env
    environment:
      - APP_URL=http://localhost:8000
      - DB_CONNECTION=pgsql
      - DB_HOST=db
      - DB_PORT=5432
      - DB_DATABASE=${DB_DATABASE:-clms}
      - DB_USERNAME=${DB_USERNAME:-clms}
      - DB_PASSWORD=${DB_PASSWORD:-clms}
      - REDIS_CLIENT=phpredis
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - WKHTML_PDF_BINARY=/usr/bin/wkhtmltopdf
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    # run as root briefly to prep volumes, then start FPM
    user: "0:0"
    volumes:
      - ./back-end:/var/www/html
      - vendor:/var/www/html/vendor
      - composer-cache:/tmp/composer-cache
    command: >
      sh -lc '
        mkdir -p /var/www/html/vendor /tmp/composer-cache &&
        chown -R ${UID:-1000}:${GID:-1000} /var/www/html /tmp/composer-cache || true
        if [ ! -f vendor/autoload.php ]; then
          COMPOSER_CACHE_DIR=/tmp/composer-cache \
          composer install --no-dev --prefer-dist --no-interaction -vvv
          chown -R ${UID:-1000}:${GID:-1000} vendor
        fi
        exec php-fpm -F
      '
    healthcheck:
      test: ["CMD-SHELL", "php -v >/dev/null 2>&1 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
    restart: unless-stopped
    networks: [clms]

  # --- Nginx (public API proxy to php-fpm) ---
  api:
    container_name: clms-api
    build:
      context: ./back-end/dockerfiles
      dockerfile: nginx.dockerfile
      args:
        UID: ${UID:-1000}
        GID: ${GID:-1000}
        USER: ${USER:-app}
    depends_on:
      php:
        condition: service_started
    ports:
      - "8000:80"
    volumes:
      - ./back-end:/var/www/html:ro
      - ./back-end/dockerfiles/nginx:/etc/nginx/conf.d:ro
    restart: unless-stopped
    networks: [clms]

  # --- Postgres ---
  db:
    container_name: clms-db
    image: postgres:16
    environment:
      - POSTGRES_DB=${DB_DATABASE:-clms}
      - POSTGRES_USER=${DB_USERNAME:-clms}
      - POSTGRES_PASSWORD=${DB_PASSWORD:-clms}
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USERNAME:-clms} -d ${DB_DATABASE:-clms} -h localhost"]
      interval: 10s
      timeout: 5s
      retries: 10
    restart: unless-stopped
    networks: [clms]

  # --- Redis ---
  redis:
    container_name: clms-redis
    image: redis:7-alpine
    command: ["redis-server", "--appendonly", "yes"]
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 10
    restart: unless-stopped
    networks: [clms]

  # --- Next.js web (talks to api at http://api:80) ---
  web:
    container_name: clms-web
    build:
      context: ./front-end
      dockerfile: Dockerfile
      secrets:
        - secret_cookie_password
    env_file:
      - ./front-end/.env
    environment:
      - APP_NAME=CLMS
      - BACKEND_API_HOST=http://api:80
      - COOKIE_SECURE=false
      - NODE_ENV=production
    depends_on:
      api:
        condition: service_started
    ports:
      - "3000:3000"
    restart: unless-stopped
    networks: [clms]

secrets:
  secret_cookie_password:
    file: .secrets/SECRET_COOKIE_PASSWORD

volumes:
  pgdata:
  vendor:
  composer-cache:

networks:
  clms:
    driver: bridge
